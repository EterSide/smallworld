<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small World Calculator</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="page-header">
            <a href="/" class="back-link">â† ë’¤ë¡œê°€ê¸°</a>
            <h1 class="page-title">ğŸŒ Small World Calculator</h1>
        </div>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Left Panel: Deck Management -->
            <aside>
                <!-- Deck List Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">ë± ë¦¬ìŠ¤íŠ¸</span>
                        <span class="panel-badge" id="deck-count">0ì¥</span>
                    </div>

                    <!-- Search -->
                    <div class="search-wrapper">
                        <span class="search-icon">ğŸ”</span>
                        <input type="text" id="card-search" class="search-input" placeholder="ì¹´ë“œëª…ìœ¼ë¡œ ê²€ìƒ‰..."
                            autocomplete="off">
                        <div class="autocomplete-dropdown" id="search-dropdown"></div>
                    </div>

                    <!-- Deck Cards -->
                    <div id="deck-list" class="card-list">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“¦</div>
                            <p>ì¹´ë“œë¥¼ ê²€ìƒ‰í•˜ì—¬ ë±ì— ì¶”ê°€í•˜ì„¸ìš”</p>
                        </div>
                    </div>

                    <div class="action-bar">
                        <button id="save-deck-btn" class="btn btn-secondary">ğŸ’¾ ì €ì¥</button>
                        <button id="clear-deck-btn" class="btn btn-secondary">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
                    </div>
                </div>

                <!-- Selection Panel -->
                <div class="panel" style="margin-top: 1rem;">
                    <div class="panel-header">
                        <span class="panel-title">ì¹´ë“œ ì„ íƒ</span>
                    </div>

                    <div class="selection-grid">
                        <div class="selection-box" id="hand-card-box">
                            <span class="selection-box-label">íŒ¨ ì¹´ë“œ</span>
                            <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
                        </div>
                        <div class="selection-box" id="target-card-box">
                            <span class="selection-box-label">íƒ€ê²Ÿ ì¹´ë“œ</span>
                            <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
                        </div>
                    </div>

                    <div class="tabs">
                        <button class="tab active" data-mode="hand">íŒ¨ ì„ íƒ</button>
                        <button class="tab" data-mode="target">íƒ€ê²Ÿ ì„ íƒ</button>
                    </div>

                    <button id="calculate-btn" class="btn" style="width: 100%;">ğŸ” ë¸Œë¦¿ì§€ ê²½ë¡œ ì°¾ê¸°</button>
                </div>
            </aside>

            <!-- Right Panel: Results -->
            <main>
                <div class="panel">
                    <div class="results-header">
                        <h2 class="results-title">ê³„ì‚° ê²°ê³¼</h2>
                        <span class="results-count" id="results-count"></span>
                    </div>

                    <div id="results-container">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ¯</div>
                            <p>íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œë¥¼ ì„ íƒí•œ í›„<br>ë¸Œë¦¿ì§€ ê²½ë¡œ ì°¾ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</p>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script th:inline="javascript">
        // State management
        const state = {
            deck: [],
            handCard: null,
            targetCard: null,
            selectionMode: 'hand', // 'hand' or 'target'
            searchResults: [] // ê²€ìƒ‰ ê²°ê³¼ ìºì‹œ
        };

        // DOM Elements
        const cardSearch = document.getElementById('card-search');
        const searchDropdown = document.getElementById('search-dropdown');
        const deckList = document.getElementById('deck-list');
        const deckCount = document.getElementById('deck-count');
        const handCardBox = document.getElementById('hand-card-box');
        const targetCardBox = document.getElementById('target-card-box');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultsContainer = document.getElementById('results-container');
        const resultsCount = document.getElementById('results-count');
        const tabs = document.querySelectorAll('.tab');
        const saveDeckBtn = document.getElementById('save-deck-btn');
        const clearDeckBtn = document.getElementById('clear-deck-btn');

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.getElementById('toast-container').appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Search cards
        const searchCards = debounce(async (query) => {
            if (query.length < 2) {
                searchDropdown.classList.remove('active');
                return;
            }

            try {
                const response = await fetch(`/smallworld/api/search?query=${encodeURIComponent(query)}`);
                const cards = await response.json();

                // ê²€ìƒ‰ ê²°ê³¼ë¥¼ stateì— ì €ì¥
                state.searchResults = cards;

                if (cards.length === 0) {
                    searchDropdown.innerHTML = '<div class="autocomplete-item">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                } else {
                    searchDropdown.innerHTML = cards.slice(0, 10).map((card, index) => `
                    <div class="autocomplete-item" data-card-index="${index}">
                        <img src="${card.imageUrl || '/images/card-back.png'}" alt="${escapeHtml(card.name)}">
                        <div class="autocomplete-item-info">
                            <div class="autocomplete-item-name">${escapeHtml(card.name)}</div>
                            <div class="autocomplete-item-stats">
                                ${card.attribute || ''} / ${card.race || ''} / Lv.${card.level || '-'} / ATK ${card.atk ?? '?'} / DEF ${card.def ?? '?'}
                            </div>
                        </div>
                    </div>
                `).join('');
                }
                searchDropdown.classList.add('active');
            } catch (error) {
                console.error('Search failed:', error);
                showToast('ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
            }
        }, 300);

        // HTML ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add card to deck
        function addCardToDeck(card) {
            // Check if already in deck
            if (state.deck.some(c => c.id === card.id)) {
                showToast('ì´ë¯¸ ë±ì— ìˆëŠ” ì¹´ë“œì…ë‹ˆë‹¤', 'warning');
                return;
            }

            state.deck.push(card);
            renderDeck();
            saveDeckToStorage();
            showToast(`${card.name} ì¶”ê°€ë¨`, 'success');
        }

        // Remove card from deck
        function removeCardFromDeck(cardId) {
            state.deck = state.deck.filter(c => c.id !== cardId);

            // Clear selection if removed
            if (state.handCard && state.handCard.id === cardId) {
                state.handCard = null;
                renderSelectionBox(handCardBox, null, 'íŒ¨ ì¹´ë“œ');
            }
            if (state.targetCard && state.targetCard.id === cardId) {
                state.targetCard = null;
                renderSelectionBox(targetCardBox, null, 'íƒ€ê²Ÿ ì¹´ë“œ');
            }

            renderDeck();
            saveDeckToStorage();
        }

        // Select card
        function selectCard(card) {
            if (state.selectionMode === 'hand') {
                state.handCard = card;
                renderSelectionBox(handCardBox, card, 'íŒ¨ ì¹´ë“œ');
            } else {
                state.targetCard = card;
                renderSelectionBox(targetCardBox, card, 'íƒ€ê²Ÿ ì¹´ë“œ');
            }
            renderDeck(); // Update selection styles
        }

        // Render selection box
        function renderSelectionBox(box, card, label) {
            if (card) {
                box.classList.add('filled');
                box.innerHTML = `
                <span class="selection-box-label">${label}</span>
                <img src="${card.imageUrl || '/images/card-back.png'}" alt="${card.name}">
                <span class="name">${card.name}</span>
            `;
            } else {
                box.classList.remove('filled');
                box.innerHTML = `
                <span class="selection-box-label">${label}</span>
                <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
            `;
            }
        }

        // Render deck list
        function renderDeck() {
            if (state.deck.length === 0) {
                deckList.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“¦</div>
                    <p>ì¹´ë“œë¥¼ ê²€ìƒ‰í•˜ì—¬ ë±ì— ì¶”ê°€í•˜ì„¸ìš”</p>
                </div>
            `;
            } else {
                deckList.innerHTML = state.deck.map(card => {
                    const isHandSelected = state.handCard && state.handCard.id === card.id;
                    const isTargetSelected = state.targetCard && state.targetCard.id === card.id;
                    const selectedClass = (isHandSelected || isTargetSelected) ? 'selected' : '';

                    return `
                    <div class="card-item ${selectedClass}" data-card-id="${card.id}">
                        <img src="${card.imageUrl || '/images/card-back.png'}" alt="${card.name}">
                        <div class="card-item-info">
                            <div class="card-item-name">${card.name}</div>
                            <div class="card-item-stats">
                                ${card.attribute || '-'} / ${card.race || '-'} / Lv.${card.level || '-'} / ${card.atk ?? '?'}/${card.def ?? '?'}
                            </div>
                        </div>
                        <button class="card-item-remove" data-remove-id="${card.id}">âœ•</button>
                    </div>
                `;
                }).join('');
            }
            deckCount.textContent = `${state.deck.length}ì¥`;
        }

        // Calculate paths
        async function calculatePaths() {
            if (!state.handCard || !state.targetCard) {
                showToast('íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œë¥¼ ëª¨ë‘ ì„ íƒí•˜ì„¸ìš”', 'warning');
                return;
            }

            if (state.handCard.id === state.targetCard.id) {
                showToast('íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œëŠ” ë‹¬ë¼ì•¼ í•©ë‹ˆë‹¤', 'warning');
                return;
            }

            resultsContainer.innerHTML = '<div class="loading"><div class="loading-spinner"></div></div>';

            try {
                const response = await fetch('/smallworld/api/calculate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        handCardId: state.handCard.id,
                        targetCardId: state.targetCard.id,
                        deckCardIds: state.deck.map(c => c.id)
                    })
                });

                const paths = await response.json();
                renderPaths(paths);
            } catch (error) {
                console.error('Calculate failed:', error);
                showToast('ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
                resultsContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âŒ</div><p>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</p></div>';
            }
        }

        // Render paths
        function renderPaths(paths) {
            resultsCount.textContent = `${paths.length}ê°œì˜ ê²½ë¡œ ë°œê²¬`;

            if (paths.length === 0) {
                resultsContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ˜”</div>
                    <p>ê°€ëŠ¥í•œ ë¸Œë¦¿ì§€ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤</p>
                    <p style="font-size: 0.85rem; color: var(--text-muted);">
                        ë‹¤ë¥¸ ì¹´ë“œ ì¡°í•©ì„ ì‹œë„í•´ë³´ì„¸ìš”
                    </p>
                </div>
            `;
                return;
            }

            resultsContainer.innerHTML = `
            <div class="path-grid">
                ${paths.map(path => `
                    <div class="path-card">
                        <div class="path-flow">
                            <div class="path-card-item">
                                <img src="${path.handCard.imageUrl || '/images/card-back.png'}" alt="${path.handCard.name}">
                                <span class="name">${path.handCard.name}</span>
                            </div>
                            <span class="path-arrow">â†’</span>
                            <div class="path-card-item">
                                <img src="${path.bridgeCard.imageUrl || '/images/card-back.png'}" alt="${path.bridgeCard.name}">
                                <span class="name">${path.bridgeCard.name}</span>
                            </div>
                            <span class="path-arrow">â†’</span>
                            <div class="path-card-item">
                                <img src="${path.targetCard.imageUrl || '/images/card-back.png'}" alt="${path.targetCard.name}">
                                <span class="name">${path.targetCard.name}</span>
                            </div>
                        </div>
                        <div class="path-match-info">
                            <div>íŒ¨â†’ë¸Œë¦¿ì§€: <span>${path.handToBridgeMatch}</span></div>
                            <div>ë¸Œë¦¿ì§€â†’íƒ€ê²Ÿ: <span>${path.bridgeToTargetMatch}</span></div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
        }

        // Local storage
        function saveDeckToStorage() {
            localStorage.setItem('smallworld-deck', JSON.stringify(state.deck.map(c => c.id)));
        }

        async function loadDeckFromStorage() {
            const savedIds = JSON.parse(localStorage.getItem('smallworld-deck') || '[]');
            if (savedIds.length === 0) return;

            try {
                const response = await fetch('/smallworld/api/cards', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(savedIds)
                });
                state.deck = await response.json();
                renderDeck();
            } catch (error) {
                console.error('Failed to load deck:', error);
            }
        }

        // Event listeners
        cardSearch.addEventListener('input', (e) => searchCards(e.target.value));

        searchDropdown.addEventListener('click', (e) => {
            const item = e.target.closest('.autocomplete-item');
            if (item && item.dataset.cardIndex !== undefined) {
                const index = parseInt(item.dataset.cardIndex);
                const card = state.searchResults[index];
                if (card) {
                    addCardToDeck(card);
                    cardSearch.value = '';
                    searchDropdown.classList.remove('active');
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!searchDropdown.contains(e.target) && e.target !== cardSearch) {
                searchDropdown.classList.remove('active');
            }
        });

        deckList.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.card-item-remove');
            if (removeBtn) {
                e.stopPropagation();
                removeCardFromDeck(parseInt(removeBtn.dataset.removeId));
                return;
            }

            const cardItem = e.target.closest('.card-item');
            if (cardItem) {
                const cardId = parseInt(cardItem.dataset.cardId);
                const card = state.deck.find(c => c.id === cardId);
                if (card) selectCard(card);
            }
        });

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.selectionMode = tab.dataset.mode;
            });
        });

        calculateBtn.addEventListener('click', calculatePaths);

        saveDeckBtn.addEventListener('click', () => {
            saveDeckToStorage();
            showToast('ë±ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        });

        clearDeckBtn.addEventListener('click', () => {
            if (confirm('ë±ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                state.deck = [];
                state.handCard = null;
                state.targetCard = null;
                renderDeck();
                renderSelectionBox(handCardBox, null, 'íŒ¨ ì¹´ë“œ');
                renderSelectionBox(targetCardBox, null, 'íƒ€ê²Ÿ ì¹´ë“œ');
                localStorage.removeItem('smallworld-deck');
                showToast('ë±ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            }
        });

        // Initialize
        loadDeckFromStorage();
    </script>
</body>

</html>