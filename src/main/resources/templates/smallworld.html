<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small World Calculator</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="page-header">
            <a href="/" class="back-link">â† ë’¤ë¡œê°€ê¸°</a>
            <h1 class="page-title">ğŸŒ Small World Calculator</h1>
        </div>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Left Panel: Deck Management -->
            <aside>
                <!-- Deck List Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">ë± ë¦¬ìŠ¤íŠ¸</span>
                        <span class="panel-badge" id="deck-count">0ì¥</span>
                    </div>

                    <!-- Search -->
                    <div class="search-wrapper">
                        <span class="search-icon">ğŸ”</span>
                        <input type="text" id="card-search" class="search-input" placeholder="ì¹´ë“œëª…ìœ¼ë¡œ ê²€ìƒ‰..."
                            autocomplete="off">
                        <div class="autocomplete-dropdown" id="search-dropdown"></div>
                    </div>

                    <!-- Deck Cards -->
                    <div id="deck-list" class="card-list">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“¦</div>
                            <p>ì¹´ë“œë¥¼ ê²€ìƒ‰í•˜ì—¬ ë±ì— ì¶”ê°€í•˜ì„¸ìš”</p>
                        </div>
                    </div>

                    <div class="action-bar">
                        <button id="save-deck-btn" class="btn btn-secondary">ğŸ’¾ ì €ì¥</button>
                        <button id="clear-deck-btn" class="btn btn-secondary">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
                    </div>
                </div>

                <!-- Saved Decks Panel -->
                <div class="panel" style="margin-top: 1rem;">
                    <div class="panel-header">
                        <span class="panel-title">ì €ì¥ëœ ë±</span>
                    </div>
                    <div id="saved-decks-list" class="saved-deck-list">
                        <!-- Saved decks will be rendered here -->
                        <div class="empty-state" style="padding: 1rem;">
                            <p style="font-size: 0.8rem;">ì €ì¥ëœ ë±ì´ ì—†ìŠµë‹ˆë‹¤</p>
                        </div>
                    </div>
                </div>

                <!-- Selection Panel -->
                <div class="panel" style="margin-top: 1rem;">
                    <div class="panel-header">
                        <span class="panel-title">ì¹´ë“œ ì„ íƒ</span>
                    </div>

                    <div class="selection-grid">
                        <div class="selection-box" id="hand-card-box">
                            <span class="selection-box-label">íŒ¨ ì¹´ë“œ</span>
                            <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
                        </div>
                        <div class="selection-box" id="target-card-box">
                            <span class="selection-box-label">íƒ€ê²Ÿ ì¹´ë“œ</span>
                            <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
                        </div>
                    </div>

                    <div class="tabs">
                        <button class="tab active" data-mode="hand">íŒ¨ ì„ íƒ</button>
                        <button class="tab" data-mode="target">íƒ€ê²Ÿ ì„ íƒ</button>
                    </div>

                    <button id="calculate-btn" class="btn" style="width: 100%;">ğŸ” ë¸Œë¦¿ì§€ ê²½ë¡œ ì°¾ê¸°</button>
                </div>
            </aside>

            <!-- Right Panel: Results -->
            <main>
                <div class="panel">
                    <div class="results-header">
                        <h2 class="results-title">ê³„ì‚° ê²°ê³¼</h2>
                        <span class="results-count" id="results-count"></span>
                    </div>

                    <div id="results-container">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ¯</div>
                            <p>íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œë¥¼ ì„ íƒí•œ í›„<br>ë¸Œë¦¿ì§€ ê²½ë¡œ ì°¾ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”</p>
                        </div>
                    </div>
                </div>

                <!-- Common Hand Traps Panel -->
                <div class="panel" style="margin-top: 1rem;">
                    <div class="panel-header">
                        <span class="panel-title">ìì£¼ ì“°ì´ëŠ” ì¹´ë“œ (íŒ¨íŠ¸ë© ë“±)</span>
                    </div>
                    <div class="common-cards-grid" id="common-cards-list">
                        <!-- Items will be populated by JS or static HTML -->
                        <button class="common-card-btn" data-search="Droll & Lock Bird">
                            <span class="en">Droll & Lock Bird</span>
                            <span class="ko">ë“œë¡¤ & ë¡œí¬ ë²„ë“œ</span>
                        </button>
                        <button class="common-card-btn" data-search="Effect Veiler">
                            <span class="en">Effect Veiler</span>
                            <span class="ko">ì´í™íŠ¸ ëµëŸ¬</span>
                        </button>
                        <button class="common-card-btn" data-search="Ash Blossom & Joyous Spring">
                            <span class="en">Ash Blossom & Joyous Spring</span>
                            <span class="ko">í•˜ë£¨ ìš°ë¼ë¼</span>
                        </button>
                        <button class="common-card-btn" data-search="Ghost Ogre & Snow Rabbit">
                            <span class="en">Ghost Ogre & Snow Rabbit</span>
                            <span class="ko">ìœ ë ¹í† ë¼</span>
                        </button>
                        <button class="common-card-btn" data-search="Ghost Belle & Haunted Mansion">
                            <span class="en">Ghost Belle & Haunted Mansion</span>
                            <span class="ko">ì €íƒ ì™€ë¼ì‹œ</span>
                        </button>
                        <button class="common-card-btn" data-search="Ghost Reaper & Winter Cherries">
                            <span class="en">Ghost Reaper & Winter Cherries</span>
                            <span class="ko">ë¶€ìœ ë²šê½ƒ</span>
                        </button>
                        <button class="common-card-btn" data-search="Ghost Sister & Spooky Dogwood">
                            <span class="en">Ghost Sister & Spooky Dogwood</span>
                            <span class="ko">í•˜ë‚˜ ë¯¸ì¦ˆí‚¤</span>
                        </button>
                        <button class="common-card-btn" data-search="Ghost Mourner & Moonlit Chill">
                            <span class="en">Ghost Mourner & Moonlit Chill</span>
                            <span class="ko">ì‚¬ìš” ì‹œêµ¬ë ˆ</span>
                        </button>
                        <button class="common-card-btn" data-search="Mulcharmy Purulia">
                            <span class="en">Mulcharmy Purulia</span>
                            <span class="ko">ë§ì± ë¯¸ í‘¸ë£¨ë¦¬ì•„</span>
                        </button>
                        <button class="common-card-btn" data-search="Mulcharmy Fuwalos">
                            <span class="en">Mulcharmy Fuwalos</span>
                            <span class="ko">ë§ì± ë¯¸ í›„ì™€ë¡œìŠ¤</span>
                        </button>
                        <button class="common-card-btn" data-search="Mulcharmy Meowls">
                            <span class="en">Mulcharmy Meowls</span>
                            <span class="ko">ë§ì± ë¯¸ ëƒë£¨ìŠ¤</span>
                        </button>
                        <button class="common-card-btn" data-search="Nibiru, the Primal Being">
                            <span class="en">Nibiru, the Primal Being</span>
                            <span class="ko">ì›ì‹œìƒëª…ì²´ ë‹ˆë¹„ë£¨</span>
                        </button>
                        <button class="common-card-btn" data-search="Retaliating &quot;C&quot;">
                            <span class="en">Retaliating "C"</span>
                            <span class="ko">ì‘ì „ì˜ G</span>
                        </button>
                        <button class="common-card-btn" data-search="Maxx &quot;C&quot;">
                            <span class="en">Maxx "C"</span>
                            <span class="ko">ì¦ì‹ì˜ G</span>
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script th:inline="javascript">
        // State management
        const state = {
            deck: [],
            handCard: null,
            targetCard: null,
            selectionMode: 'hand', // 'hand' or 'target'
            searchResults: [],
            savedDecks: [] // {id, name, cardIds, date}
        };

        // DOM Elements
        const cardSearch = document.getElementById('card-search');
        const searchDropdown = document.getElementById('search-dropdown');
        const deckList = document.getElementById('deck-list');
        const deckCount = document.getElementById('deck-count');
        const handCardBox = document.getElementById('hand-card-box');
        const targetCardBox = document.getElementById('target-card-box');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultsContainer = document.getElementById('results-container');
        const resultsCount = document.getElementById('results-count');
        const tabs = document.querySelectorAll('.tab');
        const saveDeckBtn = document.getElementById('save-deck-btn');
        const clearDeckBtn = document.getElementById('clear-deck-btn');
        const savedDecksList = document.getElementById('saved-decks-list');

        // ... existing debounce, showToast ...
        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.getElementById('toast-container').appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ... existing searchCards, escapeHtml ...
        // Search cards
        const searchCards = debounce(async (query) => {
            if (query.length < 2) {
                searchDropdown.classList.remove('active');
                return;
            }

            try {
                const response = await fetch(`/smallworld/api/search?query=${encodeURIComponent(query)}`);
                const cards = await response.json();

                // ê²€ìƒ‰ ê²°ê³¼ë¥¼ stateì— ì €ì¥
                state.searchResults = cards;

                if (cards.length === 0) {
                    searchDropdown.innerHTML = '<div class="autocomplete-item">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                } else {
                    searchDropdown.innerHTML = cards.slice(0, 10).map((card, index) => `
                    <div class="autocomplete-item" data-card-index="${index}">
                        <img src="${card.imageUrl || '/images/card-back.png'}" alt="${escapeHtml(card.name)}">
                        <div class="autocomplete-item-info">
                            <div class="autocomplete-item-name">${escapeHtml(card.name)}</div>
                            <div class="autocomplete-item-stats">
                                ${card.attribute || ''} / ${card.race || ''} / Lv.${card.level || '-'} / ATK ${card.atk ?? '?'} / DEF ${card.def ?? '?'}
                            </div>
                        </div>
                    </div>
                `).join('');
                }
                searchDropdown.classList.add('active');
            } catch (error) {
                console.error('Search failed:', error);
                showToast('ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
            }
        }, 300);

        // HTML ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add card to deck
        function addCardToDeck(card) {
            // state.deckê°€ ë°°ì—´ì´ ì•„ë‹ ìˆ˜ ìˆìŒ
            if (!Array.isArray(state.deck)) state.deck = [];
            if (state.deck.some(c => c.id === card.id)) {
                showToast('ì´ë¯¸ ë±ì— ìˆëŠ” ì¹´ë“œì…ë‹ˆë‹¤', 'warning');
                return;
            }

            state.deck.push(card);
            renderDeck();
            saveCurrentState(); // Autosave
            showToast(`${card.name} ì¶”ê°€ë¨`, 'success');
        }

        // Remove card from deck
        function removeCardFromDeck(cardId) {
            state.deck = state.deck.filter(c => c.id !== cardId);

            // Clear selection if removed
            if (state.handCard && state.handCard.id === cardId) {
                state.handCard = null;
                renderSelectionBox(handCardBox, null, 'íŒ¨ ì¹´ë“œ');
            }
            if (state.targetCard && state.targetCard.id === cardId) {
                state.targetCard = null;
                renderSelectionBox(targetCardBox, null, 'íƒ€ê²Ÿ ì¹´ë“œ');
            }

            renderDeck();
            saveCurrentState(); // Autosave
        }

        // Select card
        function selectCard(card) {
            if (state.selectionMode === 'hand') {
                state.handCard = card;
                renderSelectionBox(handCardBox, card, 'íŒ¨ ì¹´ë“œ');
            } else {
                state.targetCard = card;
                renderSelectionBox(targetCardBox, card, 'íƒ€ê²Ÿ ì¹´ë“œ');
            }
            renderDeck(); // Update selection styles
        }

        // ... existing renderSelectionBox, renderDeck, calculatePaths, renderPaths ...
        // Render selection box
        function renderSelectionBox(box, card, label) {
            if (card) {
                box.classList.add('filled');
                box.innerHTML = `
                <span class="selection-box-label">${label}</span>
                <img src="${card.imageUrl || '/images/card-back.png'}" alt="${card.name}">
                <span class="name">${card.name}</span>
            `;
            } else {
                box.classList.remove('filled');
                box.innerHTML = `
                <span class="selection-box-label">${label}</span>
                <span class="selection-box-placeholder">ë±ì—ì„œ í´ë¦­í•˜ì—¬ ì„ íƒ</span>
            `;
            }
        }

        // Render deck list
        function renderDeck() {
            if (state.deck.length === 0) {
                deckList.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“¦</div>
                    <p>ì¹´ë“œë¥¼ ê²€ìƒ‰í•˜ì—¬ ë±ì— ì¶”ê°€í•˜ì„¸ìš”</p>
                </div>
            `;
            } else {
                deckList.innerHTML = state.deck.map(card => {
                    const isHandSelected = state.handCard && state.handCard.id === card.id;
                    const isTargetSelected = state.targetCard && state.targetCard.id === card.id;
                    const selectedClass = (isHandSelected || isTargetSelected) ? 'selected' : '';

                    return `
                    <div class="card-item ${selectedClass}" data-card-id="${card.id}">
                        <img src="${card.imageUrl || '/images/card-back.png'}" alt="${card.name}">
                        <div class="card-item-info">
                            <div class="card-item-name">${card.name}</div>
                            <div class="card-item-stats">
                                ${card.attribute || '-'} / ${card.race || '-'} / Lv.${card.level || '-'} / ${card.atk ?? '?'}/${card.def ?? '?'}
                            </div>
                        </div>
                        <button class="card-item-remove" data-remove-id="${card.id}">âœ•</button>
                    </div>
                `;
                }).join('');
            }
            deckCount.textContent = `${state.deck.length}ì¥`;
        }

        // Calculate paths
        async function calculatePaths() {
            // ... existing implementation ...
            if (!state.handCard || !state.targetCard) {
                showToast('íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œë¥¼ ëª¨ë‘ ì„ íƒí•˜ì„¸ìš”', 'warning');
                return;
            }

            if (state.handCard.id === state.targetCard.id) {
                showToast('íŒ¨ ì¹´ë“œì™€ íƒ€ê²Ÿ ì¹´ë“œëŠ” ë‹¬ë¼ì•¼ í•©ë‹ˆë‹¤', 'warning');
                return;
            }

            resultsContainer.innerHTML = '<div class="loading"><div class="loading-spinner"></div></div>';

            try {
                const response = await fetch('/smallworld/api/calculate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        handCardId: state.handCard.id,
                        targetCardId: state.targetCard.id,
                        deckCardIds: state.deck.map(c => c.id)
                    })
                });

                const paths = await response.json();
                renderPaths(paths);
            } catch (error) {
                console.error('Calculate failed:', error);
                showToast('ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
                resultsContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âŒ</div><p>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</p></div>';
            }
        }

        // Render paths
        function renderPaths(paths) {
            resultsCount.textContent = `${paths.length}ê°œì˜ ê²½ë¡œ ë°œê²¬`;

            if (paths.length === 0) {
                resultsContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ˜”</div>
                    <p>ê°€ëŠ¥í•œ ë¸Œë¦¿ì§€ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤</p>
                    <p style="font-size: 0.85rem; color: var(--text-muted);">
                        ë‹¤ë¥¸ ì¹´ë“œ ì¡°í•©ì„ ì‹œë„í•´ë³´ì„¸ìš”
                    </p>
                </div>
            `;
                return;
            }

            resultsContainer.innerHTML = `
            <div class="path-grid">
                ${paths.map(path => `
                    <div class="path-card">
                        <div class="path-flow">
                            <div class="path-card-item">
                                <img src="${path.handCard.imageUrl || '/images/card-back.png'}" alt="${path.handCard.name}">
                                <span class="name">${path.handCard.name}</span>
                            </div>
                            <span class="path-arrow">â†’</span>
                            <div class="path-card-item">
                                <img src="${path.bridgeCard.imageUrl || '/images/card-back.png'}" alt="${path.bridgeCard.name}">
                                <span class="name">${path.bridgeCard.name}</span>
                            </div>
                            <span class="path-arrow">â†’</span>
                            <div class="path-card-item">
                                <img src="${path.targetCard.imageUrl || '/images/card-back.png'}" alt="${path.targetCard.name}">
                                <span class="name">${path.targetCard.name}</span>
                            </div>
                        </div>
                        <div class="path-match-info">
                            <div>íŒ¨â†’ë¸Œë¦¿ì§€: <span>${path.handToBridgeMatch}</span></div>
                            <div>ë¸Œë¦¿ì§€â†’íƒ€ê²Ÿ: <span>${path.bridgeToTargetMatch}</span></div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
        }

        // ==========================================
        // Storage Logic (Updated)
        // ==========================================

        // Save current deck state (Autosave)
        function saveCurrentState() {
            localStorage.setItem('smallworld-deck-autosave', JSON.stringify(state.deck.map(c => c.id)));
        }

        // Load autosave
        async function loadCurrentState() {
            const savedIds = JSON.parse(localStorage.getItem('smallworld-deck-autosave') || '[]');
            if (savedIds.length === 0) return;
            await loadCardsByIds(savedIds);
        }

        // Load saved decks list
        function loadSavedDecksList() {
            const saved = localStorage.getItem('smallworld-saved-decks');
            state.savedDecks = saved ? JSON.parse(saved) : [];
            renderSavedDecks();
        }

        // Save a new named deck
        function saveNamedDeck() {
            if (state.deck.length === 0) {
                showToast('ë¹ˆ ë±ì€ ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'warning');
                return;
            }

            const name = prompt('ë± ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:');
            if (!name || name.trim() === '') return;

            const newDeck = {
                id: Date.now(),
                name: name.trim(),
                cardIds: state.deck.map(c => c.id),
                date: new Date().toLocaleDateString()
            };

            state.savedDecks.push(newDeck);
            localStorage.setItem('smallworld-saved-decks', JSON.stringify(state.savedDecks));
            renderSavedDecks();
            showToast(`'${name}' ë±ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤`, 'success');
        }

        // Load a specific saved deck
        async function loadNamedDeck(deckId) {
            const savedDeck = state.savedDecks.find(d => d.id === deckId);
            if (!savedDeck) return;

            if (confirm(`'${savedDeck.name}' ë±ì„ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ? í˜„ì¬ ì‘ì„± ì¤‘ì¸ ë±ì€ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤.`)) {
                await loadCardsByIds(savedDeck.cardIds);
                showToast(`'${savedDeck.name}' ë±ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤`, 'success');
            }
        }

        // Delete a saved deck
        function deleteNamedDeck(deckId) {
            if (confirm('ì •ë§ ì´ ë±ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                state.savedDecks = state.savedDecks.filter(d => d.id !== deckId);
                localStorage.setItem('smallworld-saved-decks', JSON.stringify(state.savedDecks));
                renderSavedDecks();
                showToast('ë±ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
            }
        }

        // Helper to load cards from server by IDs
        async function loadCardsByIds(ids) {
            try {
                const response = await fetch('/smallworld/api/cards', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ids)
                });
                const data = await response.json();
                state.deck = Array.isArray(data) ? data : [];

                // Clear selection
                state.handCard = null;
                state.targetCard = null;
                renderSelectionBox(handCardBox, null, 'íŒ¨ ì¹´ë“œ');
                renderSelectionBox(targetCardBox, null, 'íƒ€ê²Ÿ ì¹´ë“œ');

                renderDeck();
                saveCurrentState();
            } catch (error) {
                console.error('Failed to load deck:', error);
                showToast('ë± ë¡œë”© ì‹¤íŒ¨', 'error');
            }
        }

        // Render saved decks list UI
        function renderSavedDecks() {
            if (state.savedDecks.length === 0) {
                savedDecksList.innerHTML = `
                    <div class="empty-state" style="padding: 1rem;">
                        <p style="font-size: 0.8rem;">ì €ì¥ëœ ë±ì´ ì—†ìŠµë‹ˆë‹¤</p>
                    </div>`;
                return;
            }

            savedDecksList.innerHTML = state.savedDecks.map(deck => `
                <div class="saved-deck-item" onclick="loadNamedDeck(${deck.id})">
                    <div class="saved-deck-info">
                        <div class="saved-deck-name">${escapeHtml(deck.name)}</div>
                        <div class="saved-deck-meta">${deck.cardIds.length}ì¥ â€¢ ${deck.date}</div>
                    </div>
                    <button class="saved-deck-delete" onclick="event.stopPropagation(); deleteNamedDeck(${deck.id})">ğŸ—‘ï¸</button>
                </div>
            `).join('');
        }

        // Make functions global for inline onclick handlers
        window.loadNamedDeck = loadNamedDeck;
        window.deleteNamedDeck = deleteNamedDeck;

        // ... existing event listeners ...
        // Event listeners
        cardSearch.addEventListener('input', (e) => searchCards(e.target.value));

        searchDropdown.addEventListener('click', (e) => {
            const item = e.target.closest('.autocomplete-item');
            if (item && item.dataset.cardIndex !== undefined) {
                const index = parseInt(item.dataset.cardIndex);
                const card = state.searchResults[index];
                if (card) {
                    addCardToDeck(card);
                    cardSearch.value = '';
                    searchDropdown.classList.remove('active');
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!searchDropdown.contains(e.target) && e.target !== cardSearch) {
                searchDropdown.classList.remove('active');
            }
        });

        // Deck list item click/remove
        deckList.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.card-item-remove');
            if (removeBtn) {
                e.stopPropagation();
                removeCardFromDeck(parseInt(removeBtn.dataset.removeId));
                return;
            }

            const cardItem = e.target.closest('.card-item');
            if (cardItem) {
                const cardId = parseInt(cardItem.dataset.cardId);
                const card = state.deck.find(c => c.id === cardId);
                if (card) selectCard(card);
            }
        });

        // Tabs
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.selectionMode = tab.dataset.mode;
            });
        });

        calculateBtn.addEventListener('click', calculatePaths);

        // Update Save button to use named save
        saveDeckBtn.addEventListener('click', () => {
            saveNamedDeck();
        });

        clearDeckBtn.addEventListener('click', () => {
            if (confirm('ë±ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                state.deck = [];
                state.handCard = null;
                state.targetCard = null;
                renderDeck();
                renderSelectionBox(handCardBox, null, 'íŒ¨ ì¹´ë“œ');
                renderSelectionBox(targetCardBox, null, 'íƒ€ê²Ÿ ì¹´ë“œ');
                saveCurrentState(); // Update autosave
                showToast('ë±ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            }
        });

        // Initialize (Load both autosave and saved decks list)
        loadCurrentState();
        loadSavedDecksList();

        // Common Cards Click Handler
        document.getElementById('common-cards-list').addEventListener('click', async (e) => {
            const btn = e.target.closest('.common-card-btn');
            if (!btn) return;

            const searchName = btn.dataset.search;
            if (!searchName) return;

            // Visual feedback
            const originalBg = btn.style.backgroundColor;
            btn.style.backgroundColor = 'var(--primary-light)';

            try {
                // 1. Search for exact match first
                const response = await fetch(`/smallworld/api/search?query=${encodeURIComponent(searchName)}`);
                const cards = await response.json();

                // 2. Find exact match (ignoring case)
                const exactMatch = cards.find(c => c.name.toLowerCase() === searchName.toLowerCase());

                if (exactMatch) {
                    addCardToDeck(exactMatch);
                } else if (cards.length > 0) {
                    // Fallback to first result if partial match found
                    addCardToDeck(cards[0]);
                } else {
                    showToast(`'${searchName}' ì¹´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`, 'error');
                }
            } catch (error) {
                console.error('Common card add failed:', error);
                showToast('ì¹´ë“œ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
            } finally {
                setTimeout(() => {
                    btn.style.backgroundColor = originalBg;
                }, 200);
            }
        });
    </script>
</body>

</html>